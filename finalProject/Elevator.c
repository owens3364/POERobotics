#pragma config(Sensor, dgtl1,  firstFloorButton, sensorTouch)
#pragma config(Sensor, dgtl2,  secondFloorButton, sensorTouch)
#pragma config(Sensor, dgtl3,  thirdFloorButton, sensorTouch)
#pragma config(Sensor, dgtl7,  sonar,          sensorSONAR_mm)
#pragma config(Motor,  port2,           elevatorMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           floorIndicator, tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

static const byte MOTOR_DIRECTION = 1; // Multiplied by motor power makes it easy to fix inverted motor powers // TODO: Update this
static const byte MOTOR_SPEED = 127; //Speed of motor

static const byte OPPOSITE = -1; // Multiplied by values that need to be inverted

static const byte TOLERANCE = 2.5; // Minimum distance allowed between target position and actual positon, in mm

static const byte INACTIVITY_TIMEOUT = 30; // Time allowed for no activity before the elevator is disabled permanently

static const byte FIRST_FLOOR_SERVO_VALUE = 127 / 2;
static const byte SECOND_FLOOR_SERVO_VALUE = 0;
static const byte THIRD_FLOOR_SERVO_VALUE = -127 / 2;

static const float MM_PER_INCH = 25.4; // For converting inches to mm for accurate use with the sonar sensor
static const float FIRST_FLOOR_SONAR_READING = 2.25 * MM_PER_INCH;
static const float SECOND_FLOOR_SONAR_READING = 5.44 * MM_PER_INCH;
static const float THIRD_FLOOR_SONAR_READING = 9 * MM_PER_INCH;

static float publicTarget = 0.0; // For debugging purposes only // Me!
static bool publicTargetReached = false;

// Checks if value comparable is within the tolerance distance to the target
bool isWithin(float comparable, float target, float tolerance) {
	return abs(comparable - target) < tolerance;
}

// Checks to ensure the elevator is at the target level. If it isn't, it targets the floor with a tolerance of 4mm
void targetLevel(float targetLevel) {
	publicTarget = targetLevel;
	bool targetReached = false;
	publicTargetReached = false;
	while (!targetReached) {
		if (!isWithin(SensorValue[sonar], targetLevel, TOLERANCE)) {
			if (SensorValue[sonar] < targetLevel) {
				startMotor(elevatorMotor, MOTOR_SPEED * MOTOR_DIRECTION);
			} else if (SensorValue[sonar] > targetLevel) {
				startMotor(elevatorMotor, MOTOR_SPEED * MOTOR_DIRECTION * OPPOSITE);
			}
		} else {
			targetReached = true;
			publicTargetReached = true;
		}
	}
	stopMotor(elevatorMotor);
}

// Updates the lights to show where the elevator is at
void updateLevel(float lvl) {
	if (lvl == FIRST_FLOOR_SONAR_READING) {
		setServo(floorIndicator, FIRST_FLOOR_SERVO_VALUE);
	} else if (lvl == SECOND_FLOOR_SONAR_READING) {
		setServo(floorIndicator, SECOND_FLOOR_SERVO_VALUE);
	} else if (lvl == THIRD_FLOOR_SONAR_READING) {
		setServo(floorIndicator, THIRD_FLOOR_SERVO_VALUE);
	}
}

// Waits for 30 seconds before stopping main and then moving to the first floor
task timeout() {
	wait(INACTIVITY_TIMEOUT);
	targetLevel(FIRST_FLOOR_SONAR_READING);
	updateLevel(FIRST_FLOOR_SERVO_VALUE);
	stopAllTasks();
}

// Has the elevator move to the target position, updates the lights, and restarts the timeout
void targetAndUpdate(float lvl) {
	targetLevel(lvl);
	updateLevel(lvl);
	startTask(timeout);
}

// Starts the timeout, and then listens for button calls or floor selections and calls targetAndUpdate(lvl) in resposne until the timeout is reached
task main() {
	startTask(timeout);
	while (true) {
		if (SensorValue[dgtl1] == 1) {
			waitUntil(SensorValue[dgtl1] == 0);
			targetAndUpdate(FIRST_FLOOR_SONAR_READING);
		} else if (SensorValue[dgtl2] == 1) {
			waitUntil(SensorValue[dgtl2] == 0);
			targetAndUpdate(SECOND_FLOOR_SONAR_READING);
		} else if (SensorValue[dgtl3] == 1) {
			waitUntil(SensorValue[dgtl3] == 0);
			targetAndUpdate(THIRD_FLOOR_SONAR_READING);
		}
	}
}
