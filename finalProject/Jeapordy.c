#pragma config(Sensor, dgtl1,  alexBtn,        sensorDigitalIn)
#pragma config(Sensor, dgtl2,  resetBtn,       sensorDigitalIn)
#pragma config(Sensor, dgtl3,  contestant1Btn, sensorDigitalIn)
#pragma config(Sensor, dgtl4,  contestant2Btn, sensorDigitalIn)
#pragma config(Sensor, dgtl5,  contestant3Btn, sensorDigitalIn)
#pragma config(Motor,  port2,           alexMotor,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port3,           contestant1Motor, tmotorServoStandard, openLoop)
#pragma config(Motor,  port4,           contestant2Motor, tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           contestant3Motor, tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

static const byte SERVO_LEFT_POSITION = 0x7D;
static const byte SERVO_UP_POSITION = -0x19;

static const byte SERVO_RIGHT_DECREMENT = -0xF;

static const byte CONTESTANT_COUNT = 0x3;
static bool contestantsThatCanAnswer[3];

static bool answerable = false;

struct ServoPositions {
	byte alexPos;
	byte contestant1Pos;
	byte contestant2Pos;
	byte contestant3Pos;
};

ServoPositions servoPositions;

bool getAnswerable() {
	hogCPU();
	bool answerableCopy = answerable;
	releaseCPU();
	return answerableCopy;
}

void setAnswerable(bool newVal) {
	hogCPU();
	answerable = newVal;
	releaseCPU();
}

void updateServos() {
	setServo(alexMotor, servoPositions.alexPos);
	setServo(contestant1Motor, servoPositions.contestant1Pos);
	setServo(contestant2Motor, servoPositions.contestant2Pos);
	setServo(contestant3Motor, servoPositions.contestant3Pos);
}

void resetToIdleState() {
	answerable = false;
	for (int i = 0; i < CONTESTANT_COUNT; i++) {
		contestantsThatCanAnswer[i] = true;
	}
	servoPositions.alexPos = SERVO_LEFT_POSITION;
	servoPositions.contestant1Pos = SERVO_LEFT_POSITION;
	servoPositions.contestant2Pos = SERVO_LEFT_POSITION;
	servoPositions.contestant3Pos = SERVO_LEFT_POSITION;
	updateServos();
}

task listenForReset() {
	while (true) {
		waitUntil(SensorValue[resetBtn] == 0);
		resetToIdleState();
	}
}

task flashLights() {
	if (getAnswerable()) {
		servoPositions.contestant1Pos -= SERVO_RIGHT_DECREMENT;
		servoPositions.contestant2Pos -= SERVO_RIGHT_DECREMENT;
		servoPositions.contestant3Pos -= SERVO_RIGHT_DECREMENT;
		updateServos();
		for (int i = 0; i < 5; i++) {
			wait(1);
			if (getAnswerable()) {
				servoPositions.contestant1Pos -= SERVO_RIGHT_DECREMENT;
				servoPositions.contestant2Pos -= SERVO_RIGHT_DECREMENT;
				servoPositions.contestant3Pos -= SERVO_RIGHT_DECREMENT;
				updateServos();
			}
		}
	}
}

void updateServosForSelectedContestant(byte contestant) {
	switch (contestant) {
		case 1:
			servoPositions.contestant1Pos = contestantsThatCanAnswer[0] ? SERVO_UP_POSITION : SERVO_LEFT_POSITION;
			servoPositions.contestant2Pos = SERVO_LEFT_POSITION;
			servoPositions.contestant3Pos = SERVO_LEFT_POSITION;
			contestantsThatCanAnswer[0] = false;
			break;
		case 2:
			servoPositions.contestant1Pos = SERVO_LEFT_POSITION;
			servoPositions.contestant2Pos = contestantsThatCanAnswer[1] ? SERVO_UP_POSITION : SERVO_LEFT_POSITION;
			servoPositions.contestant3Pos = SERVO_LEFT_POSITION;
			contestantsThatCanAnswer[1] = false;
			break;
		case 3:
			servoPositions.contestant1Pos = SERVO_LEFT_POSITION;
			servoPositions.contestant2Pos = SERVO_LEFT_POSITION;
			servoPositions.contestant3Pos = contestantsThatCanAnswer[2] ? SERVO_UP_POSITION : SERVO_LEFT_POSITION;
			contestantsThatCanAnswer[2] = false;
			break;
	}
	updateServos();
}

task listenToContestant1() {
	if (contestantsThatCanAnswer[0]) {
		waitUntil(SensorValue[contestant1Btn] == 0);
		stopTask(flashLights);
		setAnswerable(false);
		updateServosForSelectedContestant(1);
	}
}

task listenToContestant2() {
	if (contestantsThatCanAnswer[1]) {
		waitUntil(SensorValue[contestant2Btn] == 0);
		stopTask(flashLights);
		setAnswerable(false);
		updateServosForSelectedContestant(2);
	}
}

task listenToContestant3() {
	if (contestantsThatCanAnswer[2]) {
		waitUntil(SensorValue[contestant3Btn] == 0);
		stopTask(flashLights);
		setAnswerable(false);
		updateServosForSelectedContestant(3);
	}
}

task timeout() {
	wait(10);
	if (getAnswerable()) {
		stopTask(flashLights);
		stopTask(listenToContestant1);
		stopTask(listenToContestant2);
		stopTask(listenToContestant3);
		resetToIdleState();
	}
}

void waitForAnswer() {
	startTask(flashLights);
	startTask(listenToContestant1);
	startTask(listenToContestant2);
	startTask(listenToContestant3);
	startTask(timeout);
}

task main() {
	resetToIdleState();
	startTask(listenForReset);
	while (true) {
		waitUntil(SensorValue[alexBtn] == 0);
		servoPositions.alexPos = SERVO_UP_POSITION;
		updateServos();
		setAnswerable(true);
		waitForAnswer();
	}
}
