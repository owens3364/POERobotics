#pragma config(Sensor, dgtl1,  alexBtn,        sensorDigitalIn)
#pragma config(Sensor, dgtl2,  resetBtn,       sensorDigitalIn)
#pragma config(Sensor, dgtl3,  contestant1Btn, sensorDigitalIn)
#pragma config(Sensor, dgtl4,  contestant2Btn, sensorDigitalIn)
#pragma config(Sensor, dgtl5,  contestant3Btn, sensorDigitalIn)
#pragma config(Motor,  port2,           alexMotor,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port3,           contestant1Motor, tmotorServoStandard, openLoop)
#pragma config(Motor,  port4,           contestant2Motor, tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           contestant3Motor, tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

static const byte SERVO_LEFT_POSITION = 125;
static const byte SERVO_UP_POSITION = -25;

static const byte SERVO_RIGHT_DECREMENT = 25;

static const byte CONTESTANT_COUNT = 3;

static bool answerable;
static bool alteredState;
static int contestantAnswered;
static bool contestantsThatCanAnswer[3];

struct ServoPositions {
	byte alexPos;
	byte contestant1Pos;
	byte contestant2Pos;
	byte contestant3Pos;
};

ServoPositions servoPositions;

void updateServos() {
	setServo(alexMotor, servoPositions.alexPos);
	setServo(contestant1Motor, servoPositions.contestant1Pos);
	setServo(contestant2Motor, servoPositions.contestant2Pos);
	setServo(contestant3Motor, servoPositions.contestant3Pos);
}

void resetToIdleState() {
	answerable = false;
	alteredState = false;
	contestantAnswered = -1;
	for (int i = 0; i < CONTESTANT_COUNT; i++) {
		contestantsThatCanAnswer[i] = true;
	}
	servoPositions.alexPos = SERVO_LEFT_POSITION;
	servoPositions.contestant1Pos = SERVO_LEFT_POSITION;
	servoPositions.contestant2Pos = SERVO_LEFT_POSITION;
	servoPositions.contestant3Pos = SERVO_LEFT_POSITION;
	updateServos();
}

task listenForReset() {
	while (true) {
		waitUntil(SensorValue[resetBtn] == 1);
		resetToIdleState();
	}
}

task flashLights() {
	for (int i = 0; i < 10; i++) {
		wait(1);
		servoPositions.contestant1Pos -= SERVO_RIGHT_DECREMENT;
		servoPositions.contestant2Pos -= SERVO_RIGHT_DECREMENT;
		servoPositions.contestant3Pos -= SERVO_RIGHT_DECREMENT;
		updateServos();
	}
}

void updateServosForSelectedContestant(byte contestant) {
	switch (contestant) {
		case 1:
			servoPositions.contestant1Pos = contestantsThatCanAnswer[0] ? SERVO_UP_POSITION : SERVO_LEFT_POSITION;
			servoPositions.contestant2Pos = SERVO_LEFT_POSITION;
			servoPositions.contestant3Pos = SERVO_LEFT_POSITION;
		case 2:
			servoPositions.contestant1Pos = SERVO_LEFT_POSITION;
			servoPositions.contestant2Pos = contestantsThatCanAnswer[1] ? SERVO_UP_POSITION : SERVO_LEFT_POSITION;
			servoPositions.contestant3Pos = SERVO_LEFT_POSITION;
		case 3:
			servoPositions.contestant1Pos = SERVO_LEFT_POSITION;
			servoPositions.contestant2Pos = SERVO_LEFT_POSITION;
			servoPositions.contestant3Pos = contestantsThatCanAnswer[2] ? SERVO_UP_POSITION : SERVO_LEFT_POSITION;
	}
	updateServos();
}

task listenToButtons() {
	while (true) {
		if (SensorValue[contestant1Btn] == 1) {
			stopTask(flashLights);
			updateServosForSelectedContestant(1);
			break;
		} else if (SensorValue[contestant2Btn] == 1) {
			stopTask(flashLights);
			updateServosForSelectedContestant(2);
			break;
		} else if (SensorValue[contestant3Btn] == 1) {
			stopTask(flashLights);
			updateServosForSelectedContestant(3);
			break;
		}
	}
}

task timeout() {
	wait(10);
	stopTask(flashLights);
	stopTask(listenToButtons);
}

void waitForAnswer() {
	startTask(flashLights);
	startTask(listenToButtons);
	startTask(timeout);
	waitUntil(!answerable);
	stopTask(timeout);
}

task main() {
	startTask(listenForReset);
	while (true) {
		waitUntil(SensorValue[alexBtn] == 1);
		servoPositions.alexPos = SERVO_UP_POSITION;
		updateServos();

		answerable = true;
		alteredState = false;
		waitForAnswer();
		alteredState = true;
	}
}
